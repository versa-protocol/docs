---
title: "Sending Client Implementation"
---

# Sending Client Implementation

Developer documentation for implementing a Versa sender client on your stack. There are three steps:

1. **[Register the Transaction](#1-register-the-transaction)**
2. **[Encrypt the Receipt](#2-encrypt-the-receipt)**
3. **[Send the Receipt](#3-send-the-receipt)**

## 1. Register the Transaction

Review the [registration specification](/sending#1-register-the-transaction).

<TabGroup>
  <Tab title="Rust">
    ```rust
    #[derive(Serialize)]
    pub struct ReceiptRegistrationRequest {
        pub schema_version: String,
        pub handles: TransactionHandles,
        pub transaction_id: Option<String>,
    }

    #[derive(Deserialize)]
    #[serde(rename_all = "snake_case")]
    pub enum VersaEnv {
        Prod,
        Test,
    }

    #[derive(Deserialize)]
    pub struct ReceiptRegistrationResponse {
        /// If you are using test credentials, receipts will not be routed to production receivers
        pub env: VersaEnv,
        /// It's recommended that you store this for logging and debugging purposes
        pub receipt_id: String,
        /// Make sure to store this if you have a workflow where receipts may need to be updated, e.g. with a tip or refund
        pub transaction_id: String,
        /// All authorized receivers for the provided transaction handles
        pub receivers: Vec<Receiver>,
        /// Encrypt the receipt data using this key and a 12-byte nonce that you generate for each receiver
        pub encryption_key: String,
    }

    pub async fn register(
        client_id: &str,
        client_secret: &str,
        handles: TransactionHandles,
        registration_hash: u64,
    ) -> Result<ReceiptRegistrationResponse, ()> {
      let registry_url = "https://registry.versa.org".to_string();
      let credential = format!("Basic {}:{}", client_id, client_secret);

      let payload = ReceiptRegistrationRequest {
        schema_version: "1.2.0".into(),
        handles,
        transaction_id: None, // Populate with the previously provided transaction ID if you are updating a previously registered receipt
      };

      let payload_json = serde_json::to_string(&payload).unwrap();

      let url = format!("{}/register", registry_url);
      kirk!("Sending registration request to: {}", url);
      let client = reqwest::Client::new();
      let response_result = client
        .post(url)
        .header("Accept", "application/json")
        .header("Authorization", credential)
        .header("Content-Type", "application/json")
        .body(payload_json)
        .send()
        .await;

      let res = match response_result {
        Ok(res) => res,
        Err(e) => {
          kirk!("Error placing request: {:?}", e);
          return Err(());
        }
      };
      kirk!("Registration response received");

      if res.status().is_success() {
        let data: ReceiptRegistrationResponse = match res.json().await {
          Ok(val) => val,
          Err(e) => {
            kirk!("Failed to deserialize due to error: {}", e);
            return Err(());
          }
        };
        return Ok(data);
      } else {
        kirk!("Received error status from registry: {}", res.status());
      }

      return Err(());
    }
    ```
  </Tab>
  <Tab title="Java">
    ```Java

		// make post request to registry
		RestTemplate restTemplate = new RestTemplate();

    // Make the HTTP POST request
    String url = versaRegistryUrl + "/register";

		String credential = "Basic " + versaClientId + ":" + versaClientSecret;

    HttpHeaders headers = new HttpHeaders();
    headers.set("Accept", "application/json");
    headers.set("Authorization", credential);
    headers.set("Content-Type", "application/json");

    // Create the HTTP entity
    HttpEntity<ReceiptRegistrationRequest> entity = new HttpEntity<>(registrationPayload, headers);

			try {
      // Make the HTTP POST request
      ResponseEntity<String> response = restTemplate.exchange(
          url,
          HttpMethod.POST,
          entity,
          String.class
      );
      if (response.getStatusCode() == HttpStatus.OK) {
          // Deserialize the response body into ReceiptRegistrationResponse
          ReceiptRegistrationResponse data = objectMapper.readValue(
              response.getBody(),
              ReceiptRegistrationResponse.class
          );
					// Successfully deserialized a response from the registry with the receipt_id, transaction_id, env, and receivers
					System.out.println("Successfully registered receipt with registry: " + data.receipt_id);
                } else {
                    // Log the failure status
                    System.out.println("Received error status from registry: " + response.getStatusCode());
                }
            } catch (Exception e) {
                // Log the error (replace kirk! with a logger)
                System.out.println("Error during registration: " + e.getMessage());
            }    
    ```
  </Tab>
</TabGroup>

## 2. Encrypt the Receipt

Versa uses AES-GCM-SIV for the symmetric encryption of receipts. The receiver must check out the key from the registry, confirming that they have up-to-date credentials and authorization for the delivery.

<TabGroup>
  <Tab title="Rust">
    ```rust
    use aes_gcm_siv::{aead::Aead, Aes256GcmSiv, KeyInit, Nonce};
    use base64::prelude::*;
    use rand::Rng;
    use serde::Serialize;
    use serde_json::json;

    #[derive(Debug, Serialize)]
    pub struct Envelope {
        pub encrypted: String,
        pub nonce: String,
    }

/// Generates a 12 byte nonce, suitable for use with the AES-GCM-SIV algorithm
/// The nonce will be sent to each receiver; while the key is not.
/// You may choose to generate a new nonce for each receiver, or reuse a nonce for multiple receivers.
fn generate_nonce() -> [u8; 12] {
    let mut rng = rand::thread_rng();
    let mut nonce = [0u8; 12];
    rng.fill(&mut nonce);
    nonce
}

/// Encrypts the receipt data using the 32-byte key, which is provided by the registry when you register a receipt
pub fn encrypt_envelope<T>(data: &T, key: &Vec<u8>) -> Envelope
  where
    T: Serialize,
{
    let serde_json = json!(data);

    let nonce_bytes = generate_nonce();
    let nonce = Nonce::from_slice(&nonce_bytes); // unique to each receiver and included in message
    let cipher = Aes256GcmSiv::new(key[..].into());
    let encrypted = match cipher.encrypt(nonce, canonicalized.as_bytes()) {
        Ok(ciphertext) => BASE64_STANDARD.encode(ciphertext),
        Err(e) => panic!("Error encrypting data: {}", e),
    };
    Envelope {
        encrypted,
        nonce: BASE64_STANDARD.encode(nonce_bytes),
    }

}

    ```

  </Tab>
  <Tab title="Java">
    ```java
package com.yourco.sender;

import java.io.ByteArrayOutputStream;
import java.security.Key;

import javax.crypto.Cipher;
import javax.crypto.spec.GCMParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;

public class Protocol {

    /// Encrypts the input using the 32-byte key, which is provided by the registry when you register a receipt, and a 12-byte nonce
    /// `input` is a JSON-serialized String of the receipt data using a valid Versa schema
    public static byte[] encrypt(
        byte[]      keyBytes,
        byte[]      nonce,
        String      input)
    {
        Key                     key;

        key = new SecretKeySpec(keyBytes, "AES");

        try {
            Cipher cipher = Cipher.getInstance("AES/GCM-SIV/NoPadding", "BC");
            // GCMParameterSpec for AES-GCM-SIV with IV and tag length
            // Note that the tag (or nonce) should always be of length 12
            GCMParameterSpec gcmSpec = new GCMParameterSpec(12 * 8, nonce);
            cipher.init(Cipher.ENCRYPT_MODE, key, gcmSpec);
            byte[] encrypted =  cipher.doFinal(input.getBytes(StandardCharsets.UTF_8));
            return encrypted;
        } catch (Exception e) {
            e.printStackTrace();
            return new ByteArrayOutputStream( ).toByteArray();
        }
    }

}

    ```

  </Tab>
</TabGroup>

## 3. Send the Receipt

Review the [sending specification](/sending#3-send-the-receipt). In this final step, the client makes a POST request to each receiver, with an HMAC verification token generated using their receiver secret (provided by the registry).

<TabGroup>
  <Tab title="Rust">
    ```rust
use base64::prelude::*;
use hmac::Mac;
use serde::{Deserialize, Serialize};

#[derive(Deserialize)]
pub struct Receiver {
    pub address: String,
    pub client_id: String,
    pub org_id: String,
    pub secret: String,
}

#[derive(Serialize)]
pub struct ReceiverPayload {
    pub sender_client_id: String,
    pub receipt_id: String,
    pub envelope: Envelope,
}

/// Generate HMAC verification token using receiver secret
async fn generate_token(body: bytes::Bytes, secret: String) -> String {
    let mut mac = hmac::Hmac::<sha1::Sha1>::new_from_slice(&secret.as_bytes()).unwrap();
    mac.update(body.as_ref());
    let code_bytes = mac.finalize().into_bytes();
    let encoded = BASE64_STANDARD.encode(&code_bytes.to_vec());
    encoded
}

/// Send the encrypted payload (with data and nonce) to a given receiver
/// This should be repeated for each receiver returned by the registry
pub fn send_encrypted_payload(
    receiver: &Receiver,
    sender_client_id: String,
    receipt_id: String,
    envelope: Envelope) -> Result<(),()> {

    let payload = ReceiverPayload {
        sender_client_id,
        receipt_id,
        envelope,
    };

    let payload_json = serde_json::to_string(&payload).unwrap();
    let byte_body = bytes::Bytes::from(payload_json.clone());
    let token = generate_token(byte_body, receiver.secret.clone()).await;
    let client = reqwest::Client::new();
    let response_result = client
        .post(&receiver.address)
        .header("Content-Type", "application/json")
        .header("X-Request-Signature", token)
        .body(payload_json)
        .send()
        .await;

    let res = match response_result {
        Ok(res) => res,
        Err(e) => {
            info!("Error placing request: {:?}", e);
            return Err(());
        }
    };

    if res.status().is_success() {
        info!("Successfully sent data to receiver: {}", receiver.address);
        return Ok(());
    } else {
        let status = res.status();
        let text = res.text().await.unwrap_or_default();
        info!("Received an error from the receiver: {} {}", status, text);
    }

    return Err(());
}

    ```
  </Tab>
  <Tab title="Java">
    ```java
    package com.yourco.sender;

    import javax.crypto.Mac;
    import javax.crypto.spec.SecretKeySpec;
    import java.nio.charset.StandardCharsets;
    import java.util.Base64;

    /// Generate a base64 encoded HMAC verification token using the receiver secret provided by the registry
    public class HmacUtil {
        public static String generateHmac(String receiver_secret, byte[] payload) throws Exception {
            String algorithm = "HmacSHA1"; // For the purpose of webhook verification, SHA1 is perfectly sufficient
            SecretKeySpec secretKeySpec = new SecretKeySpec(receiver_secret.getBytes(StandardCharsets.UTF_8), algorithm);
            Mac mac = Mac.getInstance(algorithm);
            mac.init(secretKeySpec);
            byte[] hmacBytes = mac.doFinal(payload);
            return Base64.getEncoder().encodeToString(hmacBytes);
        }
    }
    ```
  </Tab>
</TabGroup>
