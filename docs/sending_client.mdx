---
title: "Sending Client Implementation"
---

# Sending Client Implementation

Developer documentation for implementing a Versa sender client on your stack. There are three steps:

1. **[Register the Transaction](#1-register-the-transaction)**
2. **[Encrypt the Receipt](#2-encrypt-the-receipt)**
3. **[Send the Receipt](#3-send-the-receipt)**

## 1. Register the Transaction

Upon completing a sale, you'll want to register the transaction with Versa. Review the [registration specification](/sending#1-register-the-transaction) for details. You'll pass the relevant customer handles to the '/register' endpoint:

<TabGroup>
  <Tab title="Rust">
    ```rust

    pub async fn register(
        client_id: &str,
        client_secret: &str,
        handles: TransactionHandles,
    ) -> () {
      let credential = format!("Basic {}:{}", client_id, client_secret);

      let payload = ReceiptRegistrationRequest {
        schema_version: "1.2.0".into(),
        handles,
        transaction_id: None, // Populate with the previously provided transaction ID if you are updating a previously registered receipt
      };

      let payload_json = serde_json::to_string(&payload).unwrap();

      kirk!("Sending registration request to: {}", url);
      let client = reqwest::Client::new();
      let response_result = client
        .post("https://registry.versa.org/register")
        .header("Accept", "application/json")
        .header("Authorization", credential)
        .header("Content-Type", "application/json")
        .body(payload_json)
        .send()
        .await;
    }
    ```

  </Tab>
  <Tab title="Java">
    <CodeWrap title="SendReceiptController.java" fileUrl="https://github.com/versa-protocol/sender-java/blob/main/src/main/java/org/versa/sender/SendReceiptController.java">
    ```java
    ReceiptRegistrationRequest registrationPayload = new ReceiptRegistrationRequest(
      schema_version,
      transaction_handles,
      transaction_id
    );

    String credential = "Basic " + versaClientId + ":" + versaClientSecret;

    HttpHeaders headers = new HttpHeaders();
    headers.set("Accept", "application/json");
    headers.set("Authorization", credential);
    headers.set("Content-Type", "application/json");

    HttpEntity<ReceiptRegistrationRequest> entity = new HttpEntity<>(registrationPayload, headers);

    RestTemplate restTemplate = new RestTemplate();
    ResponseEntity<String> response = restTemplate.exchange(
      "https://registry.versa.org/register",
      HttpMethod.POST,
      entity,
      String.class
    );
    ```
    </CodeWrap>

  </Tab>
</TabGroup>

## 2. Encrypt the Receipt

Versa uses AES-GCM-SIV for the symmetric encryption of receipts. The receiver must check out the key from the registry, confirming that they have up-to-date credentials and authorization for the delivery.

<TabGroup>
  <Tab title="Rust">
    ```rust
    use aes_gcm_siv::{aead::Aead, Aes256GcmSiv, KeyInit, Nonce};
    use base64::prelude::*;
    use rand::Rng;
    use serde::Serialize;
    use serde_json::json;

    /// Encrypts the receipt data using the 32-byte key, which is provided by the registry when you register a receipt
    pub fn encrypt_envelope<T>(data: &T, key: &Vec<u8>) -> Envelope
    where
    T: Serialize,
    {
      let serde_json = json!(data);
      let nonce_bytes = generate_nonce();
      let nonce = Nonce::from_slice(&nonce_bytes); // unique to each receiver and included in message
      let cipher = Aes256GcmSiv::new(key[..].into());
      let encrypted = match cipher.encrypt(nonce, canonicalized.as_bytes()) {
          Ok(ciphertext) => BASE64_STANDARD.encode(ciphertext),
          Err(e) => panic!("Error encrypting data: {}", e),
      };
      Envelope {
          encrypted,
          nonce: BASE64_STANDARD.encode(nonce_bytes),
      }
    }
    ```

  </Tab>
  <Tab title="Java">
      <CodeWrap title="Protocol.java" fileUrl="https://github.com/versa-protocol/sender-java/blob/main/src/main/java/org/versa/sender/Protocol.java">

    ```java
    package com.yourco.sender;

    import java.io.ByteArrayOutputStream;
    import java.security.Key;

    import javax.crypto.Cipher;
    import javax.crypto.spec.GCMParameterSpec;
    import javax.crypto.spec.SecretKeySpec;
    import java.nio.charset.StandardCharsets;

    public class Protocol {
        /// Encrypts the input using the 32-byte key, which is provided by the registry when you register a receipt, and a 12-byte nonce
        /// `input` is a JSON-serialized String of the receipt data using a valid Versa schema
        public static byte[] encrypt(
            byte[] keyBytes,
            byte[] nonce,
            String input) throws Exception
        {
            Key key = new SecretKeySpec(keyBytes, "AES");
            Cipher cipher = Cipher.getInstance("AES/GCM-SIV/NoPadding", "BC");
            GCMParameterSpec gcmSpec = new GCMParameterSpec(12 * 8, nonce);
            cipher.init(Cipher.ENCRYPT_MODE, key, gcmSpec);
            byte[] encrypted =  cipher.doFinal(input.getBytes(StandardCharsets.UTF_8));
            return encrypted
        }
    }
    ```
    </CodeWrap>

  </Tab>
</TabGroup>

## 3. Send the Receipt

Review the [sending specification](/sending#3-send-the-receipt). In this final step, the client makes a POST request to each receiver, with an HMAC verification token generated using their receiver secret (provided by the registry).

<TabGroup>
  <Tab title="Rust">
    ```rust
    use base64::prelude::*;
    use hmac::Mac;
    use serde::{Deserialize, Serialize};

    /// Generate HMAC verification token using receiver secret
    async fn generate_token(body: bytes::Bytes, secret: String) -> String {
      let mut mac = hmac::Hmac::<sha1::Sha1>::new_from_slice(&secret.as_bytes()).unwrap();
      mac.update(body.as_ref());
      let code_bytes = mac.finalize().into_bytes();
      let encoded = BASE64_STANDARD.encode(&code_bytes.to_vec());
      encoded
    }

    /// Send the encrypted payload (with data and nonce) to a given receiver
    /// This should be repeated for each receiver returned by the registry
    pub fn send_encrypted_payload(
      receiver: &Receiver,
      sender_client_id: String,
      receipt_id: String,
      envelope: Envelope
    ) -> () {

      let payload = ReceiverPayload {
          sender_client_id,
          receipt_id,
          envelope,
      };

      let payload_json = serde_json::to_string(&payload).unwrap();
      let byte_body = bytes::Bytes::from(payload_json.clone());
      let token = generate_token(byte_body, receiver.secret.clone()).await;
      let client = reqwest::Client::new();
      let response_result = client
          .post(&receiver.address)
          .header("Content-Type", "application/json")
          .header("X-Request-Signature", token)
          .body(payload_json)
          .send()
          .await;
    }

    ```

  </Tab>
  <Tab title="Java">
    <CodeWrap title="HmacUtil.java" fileUrl="https://github.com/versa-protocol/sender-java/blob/main/src/main/java/org/versa/sender/HmacUtil.java">

    ```java
    public class HmacUtil {
        public static String generateHmac(String receiver_secret, byte[] payload) throws Exception {
            String algorithm = "HmacSHA1"; // For the purpose of webhook verification, SHA1 is perfectly sufficient
            SecretKeySpec secretKeySpec = new SecretKeySpec(receiver_secret.getBytes(StandardCharsets.UTF_8), algorithm);
            Mac mac = Mac.getInstance(algorithm);
            mac.init(secretKeySpec);
            byte[] hmacBytes = mac.doFinal(payload);
            return Base64.getEncoder().encodeToString(hmacBytes);
        }
    }
    ```
    </CodeWrap>
    <CodeWrap title="SendReceiptController.java" fileUrl="https://github.com/versa-protocol/sender-java/blob/main/src/main/java/org/versa/sender/SendReceiptController.java">
    ```java
    ReceiptRegistrationResponse data = objectMapper.readValue(
            response.getBody(),
            ReceiptRegistrationResponse.class);

    for (Receiver receiver : data.receivers) {
        byte[] nonce = Nonce.generate(); // any 12-byte nonce
        byte[] encrypted_data = Protocol.encrypt(Base64.getDecoder().decode(data.encryption_key), nonce,
                payload.receipt_json);
        Envelope envelope = new Envelope(nonce, encrypted_data);
        ReceiverPayload receiverPayload = new ReceiverPayload(versaClientId, data.receipt_id, data.transaction_id, envelope);

        /// Post to the receiver address with an HMAC verification token from HmacUtil
        String receiverUrl = receiver.address;
        String hmac = HmacUtil.generateHmac(receiver.secret,
                objectMapper.writeValueAsString(receiverPayload).getBytes(StandardCharsets.UTF_8));

        HttpHeaders receiverHeaders = new HttpHeaders();
        receiverHeaders.set("Accept", "application/json");
        receiverHeaders.set("Content-Type", "application/json");
        receiverHeaders.set("X-Request-Signature", hmac);

        HttpEntity<ReceiverPayload> receiverEntity = new HttpEntity<>(receiverPayload, receiverHeaders);

        ResponseEntity<String> receiverResponse = restTemplate.exchange(
          receiverUrl,
          HttpMethod.POST,
          receiverEntity,
          String.class
        );
      }
    ```
    </CodeWrap>

  </Tab>
</TabGroup>
