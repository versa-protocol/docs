---
title: "Sending Client Implementation"
---

# Sending Client Implementation

Developer documentation for implementing a self-hosted Versa sender client, using the [Versa REST API](/sending). We currently offer client libraries for Rust and [Java](https://github.com/versa-protocol/sender-java) Not a developer? You can use our [custodial configuration](/sending#custodial-configuration) to get started.

There are three actions a Versa sender client performs:

1. **[Register the Transaction](#1-register-the-transaction)**
2. **[Encrypt the Receipt](#2-encrypt-the-receipt)**
3. **[Send the Receipt](#3-send-the-receipt)**

## 1. Register the Transaction

Upon completing a sale, you'll want to register the transaction with Versa. You'll pass the relevant customer handles, via a standard POST request, to the '/register' endpoint. If there are matched receivers, Versa will return the URL indicating where to post the receipt. Review the [registration specification](/sending#1-register-the-transaction) for details.

<TabGroup>
  <Tab title="Rust">

    ```rust
    let payload = ReceiptRegistrationRequest {
      schema_version: "1.2.0".into(),
      handles,
      transaction_id: None,
    };

    let payload_json = serde_json::to_string(&payload).unwrap();

    kirk!("Sending registration request to: {}", url);
    let client = reqwest::Client::new();
    let response_result = client
      .post("https://registry.versa.org/register")
      .header("Accept", "application/json")
      .header("Authorization", credential)
      .header("Content-Type", "application/json")
      .body(payload_json)
      .send()
      .await;
    ```

  </Tab>

  <Tab title="Java">
    <CodeWrap title="SendReceiptController.java" fileUrl="https://github.com/versa-protocol/sender-java/blob/main/src/main/java/org/versa/sender/SendReceiptController.java">

      ```java
      ReceiptRegistrationRequest registrationPayload = new ReceiptRegistrationRequest(
        schema_version,
        transaction_handles,
        transaction_id
      );

      String credential = "Basic " + versaClientId + ":" + versaClientSecret;

      HttpHeaders headers = new HttpHeaders();
      headers.set("Accept", "application/json");
      headers.set("Authorization", credential);
      headers.set("Content-Type", "application/json");

      HttpEntity<ReceiptRegistrationRequest> entity = new HttpEntity<>(registrationPayload, headers);

      RestTemplate restTemplate = new RestTemplate();
      ResponseEntity<String> response = restTemplate.exchange(
        "https://registry.versa.org/register",
        HttpMethod.POST,
        entity,
        String.class
      );
      ```

    </CodeWrap>

  </Tab>
</TabGroup>

## 2. Encrypt the Receipt

Versa uses [AES-GCM-SIV](https://en.wikipedia.org/wiki/AES-GCM-SIV) for the symmetric encryption of receipts. The receiver must check out the key from the registry, confirming that they have up-to-date credentials and authorization for the delivery.

<TabGroup>
  <Tab title="Rust">

    ```rust
    use aes_gcm_siv::{aead::Aead, Aes256GcmSiv, KeyInit, Nonce};
    use base64::prelude::*;
    use rand::Rng;
    use serde::Serialize;
    use serde_json::json;

    /// Encrypts the receipt data using the 32-byte key, which is provided by the registry when you register a receipt
    pub fn encrypt_envelope<T>(data: &T, key: &Vec<u8>) -> Envelope
    where
    T: Serialize,
    {
      let serde_json = json!(data);
      let nonce_bytes = generate_nonce();
      let nonce = Nonce::from_slice(&nonce_bytes); // unique to each receiver and included in message
      let cipher = Aes256GcmSiv::new(key[..].into());
      let encrypted = match cipher.encrypt(nonce, canonicalized.as_bytes()) {
        Ok(ciphertext) => BASE64_STANDARD.encode(ciphertext),
        Err(e) => panic!("Error encrypting data: {}", e),
      };
      Envelope {
        encrypted,
        nonce: BASE64_STANDARD.encode(nonce_bytes),
      }
    }
    ```

  </Tab>
  <Tab title="Java">
    <CodeWrap title="Protocol.java" fileUrl="https://github.com/versa-protocol/sender-java/blob/main/src/main/java/org/versa/sender/Protocol.java">

    ```java
    package com.yourco.sender;

    import java.io.ByteArrayOutputStream;
    import java.security.Key;

    import javax.crypto.Cipher;
    import javax.crypto.spec.GCMParameterSpec;
    import javax.crypto.spec.SecretKeySpec;
    import java.nio.charset.StandardCharsets;

    public class Protocol {
      /// Encrypts the input using the 32-byte key, which is provided by the registry when you register a receipt, and a 12-byte nonce
      /// `input` is a JSON-serialized String of the receipt data using a valid Versa schema
      public static byte[] encrypt(
        byte[] keyBytes,
        byte[] nonce,
        String input) throws Exception
      {
        Key key = new SecretKeySpec(keyBytes, "AES");
        Cipher cipher = Cipher.getInstance("AES/GCM-SIV/NoPadding", "BC");
        GCMParameterSpec gcmSpec = new GCMParameterSpec(12 * 8, nonce);
        cipher.init(Cipher.ENCRYPT_MODE, key, gcmSpec);
        byte[] encrypted =  cipher.doFinal(input.getBytes(StandardCharsets.UTF_8));
        return encrypted
      }
    }
    ```
    </CodeWrap>

  </Tab>
</TabGroup>

## 3. Send the Receipt

In this final step, the client makes a POST request to each receiver, with an HMAC verification token generated using their receiver secret (provided by the registry). Loop through the list of receivers returned by the registry, generate a nonce, encrypt and send the data. Review the [sending specification](/sending#3-send-the-receipt) for details.

<TabGroup>
  <Tab title="Rust">

    ```rust
    use base64::prelude::*;
    use hmac::Mac;
    use serde::{Deserialize, Serialize};

    /// Generate HMAC verification token using receiver secret
    async fn generate_token(body: bytes::Bytes, secret: String) -> String {
      let mut mac = hmac::Hmac::<sha1::Sha1>::new_from_slice(&secret.as_bytes()).unwrap();
      mac.update(body.as_ref());
      let code_bytes = mac.finalize().into_bytes();
      let encoded = BASE64_STANDARD.encode(&code_bytes.to_vec());
      encoded
    }

    /// Send the encrypted payload (with data and nonce) to a given receiver
    /// This should be repeated for each receiver returned by the registry
    pub fn send_encrypted_payload(
      receiver: &Receiver,
      sender_client_id: String,
      receipt_id: String,
      envelope: Envelope
    ) -> () {

      let payload = ReceiverPayload {
        sender_client_id,
        receipt_id,
        envelope,
      };

      let payload_json = serde_json::to_string(&payload).unwrap();
      let byte_body = bytes::Bytes::from(payload_json.clone());
      let token = generate_token(byte_body, receiver.secret.clone()).await;
      let client = reqwest::Client::new();
      let response_result = client
          .post(&receiver.address)
          .header("Content-Type", "application/json")
          .header("X-Request-Signature", token)
          .body(payload_json)
          .send()
          .await;
    }
    ```

  </Tab>
  <Tab title="Java">
    <CodeWrap title="HmacUtil.java" fileUrl="https://github.com/versa-protocol/sender-java/blob/main/src/main/java/org/versa/sender/HmacUtil.java">

    ```java
    public class HmacUtil {
      public static String generateHmac(String receiver_secret, byte[] payload) throws Exception {
        String algorithm = "HmacSHA1"; // For the purpose of webhook verification, SHA1 is perfectly sufficient
        SecretKeySpec secretKeySpec = new SecretKeySpec(receiver_secret.getBytes(StandardCharsets.UTF_8), algorithm);
        Mac mac = Mac.getInstance(algorithm);
        mac.init(secretKeySpec);
        byte[] hmacBytes = mac.doFinal(payload);
        return Base64.getEncoder().encodeToString(hmacBytes);
      }
    }
    ```

    </CodeWrap>
    <CodeWrap title="SendReceiptController.java" fileUrl="https://github.com/versa-protocol/sender-java/blob/main/src/main/java/org/versa/sender/SendReceiptController.java">
    ```java
    byte[] nonce = Nonce.generate(); // any 12-byte nonce
    byte[] encrypted_data = Protocol.encrypt(Base64.getDecoder().decode(data.encryption_key), nonce, payload.receipt_json);
    Envelope envelope = new Envelope(nonce, encrypted_data);
    ReceiverPayload receiverPayload = new ReceiverPayload(versaClientId, data.receipt_id, data.transaction_id, envelope);

    /// Post to the receiver address with an HMAC verification token from HmacUtil
    String receiverUrl = receiver.address;
    String hmac = HmacUtil.generateHmac(receiver.secret,
      objectMapper.writeValueAsString(receiverPayload).getBytes(StandardCharsets.UTF_8));

    HttpHeaders receiverHeaders = new HttpHeaders();
    receiverHeaders.set("Accept", "application/json");
    receiverHeaders.set("Content-Type", "application/json");
    receiverHeaders.set("X-Request-Signature", hmac);

    HttpEntity<ReceiverPayload> receiverEntity = new HttpEntity<>(receiverPayload, receiverHeaders);

    ResponseEntity<String> receiverResponse = restTemplate.exchange(
      receiverUrl,
      HttpMethod.POST,
      receiverEntity,
      String.class
    );
    ```
    </CodeWrap>

  </Tab>
</TabGroup>
