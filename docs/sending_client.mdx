---
title: "Sending Client Implementation"
---

# Sending Client Implementation

Developer documentation for implementing a Versa sender client on your stack.

There are three steps:

1. **[Register the Transaction](#1-register-the-transaction)**
2. **[Encrypt the Receipt](#2-encrypt-the-receipt)**
3. **[Send the Receipt](#3-send-the-receipt)**

## 1. Register the Transaction

Review the [registration specification](/sending#1-register-the-transaction).

<TabGroup>
  <Tab title="Rust">
    ```rust
    fn main() {
      println!("Hello, Rust!");
    }
    ```
  </Tab>
  <Tab title="Java">
    ```java
    fn main() {
      println!("Hello, Java!");
    }
    ```
  </Tab>
</TabGroup>

## 2. Encrypt the Receipt

Versa uses AES-GCM-SIV for the symmetric encryption of receipts. The receiver must check out the key from the registry, confirming that they have up-to-date credentials and authorization for the delivery.

<TabGroup>
  <Tab title="Rust">
    ```rust
use aes_gcm_siv::{aead::Aead, Aes256GcmSiv, KeyInit, Nonce};
use base64::prelude::*;
use rand::Rng;
use serde::Serialize;
use serde_json::json;

#[derive(Debug, Serialize)]
pub struct Envelope {
pub encrypted: String,
pub nonce: String,
}

/// Generates a 12 byte nonce, suitable for use with the AES-GCM-SIV algorithm
/// The nonce will be sent to each receiver; while the key is not.
/// You may choose to generate a new nonce for each receiver, or reuse a nonce for multiple receivers.
fn generate_nonce() -> [u8; 12] {
let mut rng = rand::thread_rng();
let mut nonce = [0u8; 12];
rng.fill(&mut nonce);
nonce
}

/// Encrypts the receipt data using the 32-byte key, which is provided by the registry when you register a receipt
pub fn encrypt_envelope<T>(data: &T, key: &Vec<u8>) -> Envelope
where
T: Serialize,
{
let serde_json = json!(data);

    let nonce_bytes = generate_nonce();
    let nonce = Nonce::from_slice(&nonce_bytes); // unique to each receiver and included in message
    let cipher = Aes256GcmSiv::new(key[..].into());
    let encrypted = match cipher.encrypt(nonce, canonicalized.as_bytes()) {
        Ok(ciphertext) => BASE64_STANDARD.encode(ciphertext),
        Err(e) => panic!("Error encrypting data: {}", e),
    };
    Envelope {
        encrypted,
        nonce: BASE64_STANDARD.encode(nonce_bytes),
    }

}

    ```

  </Tab>
  <Tab title="Java">
    ```java
package com.yourco.sender;

import java.io.ByteArrayOutputStream;
import java.security.Key;

import javax.crypto.Cipher;
import javax.crypto.spec.GCMParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;

public class Protocol {

    /// Encrypts the input using the 32-byte key, which is provided by the registry when you register a receipt, and a 12-byte nonce
    /// `input` is a JSON-serialized String of the receipt data using a valid Versa schema
    public static byte[] encrypt(
        byte[]      keyBytes,
        byte[]      nonce,
        String      input)
    {
        Key                     key;

        key = new SecretKeySpec(keyBytes, "AES");

        try {
            Cipher cipher = Cipher.getInstance("AES/GCM-SIV/NoPadding", "BC");
            // GCMParameterSpec for AES-GCM-SIV with IV and tag length
            // Note that the tag (or nonce) should always be of length 12
            GCMParameterSpec gcmSpec = new GCMParameterSpec(12 * 8, nonce);
            cipher.init(Cipher.ENCRYPT_MODE, key, gcmSpec);
            byte[] encrypted =  cipher.doFinal(input.getBytes(StandardCharsets.UTF_8));
            return encrypted;
        } catch (Exception e) {
            e.printStackTrace();
            return new ByteArrayOutputStream( ).toByteArray();
        }
    }

}

    ```

  </Tab>
</TabGroup>

## 3. Send the Receipt

Review the [sending specification](/sending#3-send-the-receipt).

<TabGroup>
  <Tab title="Rust">
    ```rust
    fn main() {
      println!("Hello, Rust!");
    }
    ```
  </Tab>
  <Tab title="Java">
    ```java
    fn main() {
      println!("Hello, Java!");
    }
    ```
  </Tab>
</TabGroup>
